#!/usr/bin/env python3
"""
IZANAGI - V01

This is a passion project toolkit for penetration testing and defensive research.
PLEASE dont be a fucking asshole, use this like a normal person.

btw this is completely a proof of concept, lmao. use at your own risk.

small note about code polish, this was fixed using alot of cursor shit. notes are not generated by me outside here and may not fully explain what i was going for.
this project is intended for ethical use only, so remember that when skimming over my fuckass code LMFAO

anyways, this letter has gone on too long.

with love,

bell <3
"""

import os
import sys
import socket
import time
import shutil
import subprocess
import json
import csv
import xml.etree.ElementTree as ET
from typing import Any, Dict, List, Optional
import getpass

# Optional dependency for colors; fallback if not available
try:
    from colorama import init as colorama_init, Fore, Style
    colorama_init()
except Exception:
    # define simple fallbacks
    class _ColorFallback:
        def __getattr__(self, name):
            return ""
    Fore = Style = _ColorFallback()

# ---------- Configuration ----------
TOOL_NAME = "IZANAGI"
TMP_DIR = os.path.join(os.getcwd(), f".{TOOL_NAME.lower()}_tmp")
VERSION = "1.0-safe"

# Create tmp dir if not exists
os.makedirs(TMP_DIR, exist_ok=True)

# ---------- Helper functions ----------
def print_ascii_art():
    art = r'''
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡤⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⡀⠀⠀⠠
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠁⠀⡂⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠤⠐⠉⠀⠀⠀⠀⠀⠀⠀
⠀⢠⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣶⣶⣶⣶⣦⣤⣀⣰⠀⠄⠇⠀⠀⠀⠀⠀⣀⠄⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠘⡌⡄⠀⠀⠀⠀⠀⣀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⢠⠀⡀⡀⠔⠈⠀⢀⡀⠀⠠⠐⠐⠂⠉⠉⠉⠉⠀⠀⠐
⠀⠀⣧⠰⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⢰⣅⠊⠀⣀⣤⣾⣷⠤⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀
⠀⠀⠈⡆⢂⠀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠸⠃⢻⣿⣟⣿⣿⣿⣿⣶⠐⢀⠀⢀⡌⠀⣂⠀⡶⠔⠀
⠀⠀⠀⠸⡌⢆⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⠛⠧⠀⠀⠀⠁⠀⣸⣿⣿⣿⣿⣿⣻⣿⢠⢄⠈⠫⢀⠀⠉⠀⠀⠀⠀
⠀⠀⠀⠀⠳⣼⣿⣯⢿⣿⣿⣿⠉⠛⠛⠛⠛⠛⠛⠂⠀⠀⠀⢠⡔⣳⢠⣿⣿⣿⣿⣟⣿⣟⣿⠉⠀⠀⠄⡈⡲⣦⡀⠀⠀⠀
⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠘⠚⢒⣿⣿⣿⣿⣷⣿⣿⢿⣿⠂⠃⠦⠒⠎⠈⠘⠿⣿⣿⣷
⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣿⣿⣇⠀⠀⠀⡀⠄⠀⠀⠀⠀⠀⠀⣴⣿⣿⣿⣿⣻⣿⣿⣿⣿⣿⠀⠀⠀⢀⡄⡀⡀⠀⠀⠈⠉
⠀⠀⠀⠀⢼⣿⣿⣿⣿⣿⣿⣽⠋⠀⠈⠀⠀⠀⠀⠀⠀⣤⡀⢘⣿⣿⣿⣿⢟⠋⣿⣿⣿⣿⣿⣄⡤⠦⠉⠀⠘⠓⢦⠀⠀⠀
⠀⠀⠀⠀⠈⢿⣿⣿⣿⣿⢿⣿⣇⠀⠀⠀⢀⢀⢄⣘⡂⠑⠀⢀⡟⣯⣵⠸⢸⣀⣿⣿⣟⣿⣿⣿⣿⠶⠄⢀⡀⠀⠘⠢⠠⠀
⠀⠀⠀⠀⠀⠀⣹⢿⣿⣿⣷⣨⣿⣶⡄⠀⠀⠀⠀⠁⠠⡠⢁⠂⡿⣟⣭⢁⣠⣿⣿⣿⣿⣿⣿⠏⠁⠀⠀⢀⣴⣿⣷⡶⢦⡄
⠀⠀⠀⠀⢀⣾⣿⠘⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⡠⣠⠾⠄⠀⠌⣿⣛⣵⣿⡿⢻⣿⣿⣿⣿⠃⠀⠀⠀⢠⣿⣿⣿⣟⡙⣦⣿
⠀⠀⠀⠀⣾⣿⣿⣧⣿⣿⣿⣿⣯⣿⣿⣷⡀⠈⠚⠁⣠⠈⠂⣸⠺⠿⣛⠃⡆⣸⣿⣿⣿⠇⠀⠀⠀⢀⣿⣿⣿⣿⣢⣿⣿⠃
⠀⠀⠀⠀⣿⣿⣿⣿⣿⡇⢿⣿⣿⣿⣿⣿⣿⡄⠀⠔⠍⢠⣾⢳⠻⣾⡓⡄⣳⣿⣿⣿⣿⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⡇⣈
⠀⠀⠀⠀⠹⣿⣿⣿⣿⣯⢸⣿⣿⡿⣿⣿⣿⣿⡆⠀⡴⠋⠉⢲⢉⡿⣣⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣧⣅
⠀⠀⠀⠀⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣬⣿⠟⠿⢷⠎⠀⠀⠀⠸⢘⠞⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⡟⡆
⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⡼⣿⣿⣿⣿⣿⣀⠀⠈⠀⠀⠀⠀⢀⠂⠀⣿⣿⣿⣿⣿⣿⣿⣇⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣇⢱
⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣿⣆⠐⠀⠀⠀⠀⡆⢀⣶⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠄⠀⢿⣿⣿⣿⣿⣿⣿⡆
⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⣡⢾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⢀⣦⣌⣿⣿⣿⣿⣿⣿⣷
⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣾⣴⣸⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣙⣷⣌⣿⣿⣿⣿⣿⢿
⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣟⣡⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣞⣿
⠀⢠⣿⣿⣿⣿⣿⣿⣿⠿⠟⠛⠋⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾
⣶⣾⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠙⣿⣿⣿⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣟⡯⠿⣿⣻
⠉⠁⠿⠿⠯⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⠙⣿
'''
    print(Fore.YELLOW + art + Style.RESET_ALL)

def banner(msg, color=Fore.YELLOW):
    print(color + f"[+] {msg}" + Style.RESET_ALL)

def error(msg):
    # Errors are shown as white/plain text under the theme
    print(Fore.WHITE + f"[-] {msg}" + Style.RESET_ALL)

def info(msg):
    # Informational messages use white under this theme
    print(Fore.WHITE + f"[*] {msg}" + Style.RESET_ALL)

# ---------- Core safe utilities ----------
def ssh_connection_check(ip: str, port: int = 22, timeout=5):
    """
    Perform a safe TCP connect to the SSH port and attempt to read the banner.
    This does NOT attempt authentication or exploit anything.
    """
    banner_text = None
    try:
        banner(f"Attempting TCP connection to SSH service at {ip}:{port}")
        with socket.create_connection((ip, port), timeout=timeout) as s:
            s.settimeout(2.0)
            try:
                data = s.recv(1024)
                banner_text = data.decode(errors="ignore").strip()
                banner(f"Received banner: {banner_text}")
            except socket.timeout:
                info("No banner received (timeout) — service might not send one immediately.")
        return True, banner_text
    except Exception as e:
        error(f"Connection failed: {e}")
        return False, None

def tcp_port_scan(ip: str, ports, timeout=0.6):
    """
    Simple TCP connect scan. Returns a dict port -> bool (open/closed)
    """
    results = {}
    banner(f"Starting TCP connect scan of {ip} on {len(ports)} port(s)...")
    for p in ports:
        try:
            with socket.create_connection((ip, p), timeout=timeout) as s:
                results[p] = True
                info(f"Port {p}: OPEN")
        except Exception:
            results[p] = False
            info(f"Port {p}: closed/unreachable")
    return results

def grab_service_banner(ip: str, port: int, timeout=2.0):
    """
    Attempt to get a service banner (without sending any payloads).
    """
    try:
        with socket.create_connection((ip, port), timeout=timeout) as s:
            s.settimeout(1.0)
            try:
                data = s.recv(2048)
                txt = data.decode(errors="ignore").strip()
                banner(f"Banner from {ip}:{port} -> {txt}")
                return txt
            except socket.timeout:
                info("No immediate banner returned.")
                return None
    except Exception as e:
        error(f"Failed to connect for banner grab: {e}")
        return None

# ---------- Structured reporting (JSON / CSV) ----------
LAST_SCAN_RESULTS: Dict[str, Any] = {}

def save_report_json(data: Dict[str, Any], filename: str) -> bool:
    try:
        with open(filename, "w", encoding="utf-8") as fh:
            json.dump(data, fh, indent=2)
        banner(f"Saved JSON report to {filename}")
        return True
    except Exception as e:
        error(f"Failed to save JSON report: {e}")
        return False

def save_report_csv(data: Dict[str, Any], filename: str) -> bool:
    """
    Save a simple CSV where each row is an observed port/service record.
    Expects data in the shape: {"target": "1.2.3.4", "ports": [{"port": 22, "open": true, "banner": "..."}, ...]}
    """
    try:
        rows = []
        ports = data.get("ports", [])
        for p in ports:
            rows.append({
                "target": data.get("target"),
                "port": p.get("port"),
                "open": p.get("open"),
                "banner": p.get("banner") or "",
            })
        with open(filename, "w", newline='', encoding="utf-8") as fh:
            writer = csv.DictWriter(fh, fieldnames=["target", "port", "open", "banner"])
            writer.writeheader()
            for r in rows:
                writer.writerow(r)
        banner(f"Saved CSV report to {filename}")
        return True
    except Exception as e:
        error(f"Failed to save CSV report: {e}")
        return False

# ---------- Nmap wrapper (uses system nmap or python-nmap fallback) ----------
def _parse_nmap_xml(xml_text: str) -> Dict[int, Dict[str, Any]]:
    """Parse minimal nmap XML output and return port -> info mapping."""
    result: Dict[int, Dict[str, Any]] = {}
    try:
        root = ET.fromstring(xml_text)
        for host in root.findall("host"):
            for ports in host.findall("ports"):
                for port in ports.findall("port"):
                    pnum = int(port.get("portid"))
                    state_el = port.find("state")
                    state = state_el.get("state") if state_el is not None else "unknown"
                    service_el = port.find("service")
                    service = service_el.get("name") if service_el is not None else None
                    result[pnum] = {"state": state, "service": service}
    except Exception:
        pass
    return result

def nmap_wrapper_scan(target: str, ports: List[int]) -> Dict[str, Any]:
    """
    Attempt to run system `nmap` with XML output. If not available, try python-nmap.
    Returns a dict with parsed results and raw output.
    """
    ports_arg = ",".join(str(p) for p in ports)
    output: Dict[str, Any] = {"target": target, "ports": []}

    # Try system nmap
    try:
        proc = subprocess.run(["nmap", "-p", ports_arg, "-oX", "-", target], capture_output=True, text=True, timeout=60)
        if proc.returncode == 0 and proc.stdout:
            parsed = _parse_nmap_xml(proc.stdout)
            for p in ports:
                info = parsed.get(p, {})
                open_state = info.get("state") == "open"
                output["ports"].append({"port": p, "open": open_state, "service": info.get("service")})
            banner("Nmap (system) scan completed.")
            output["raw"] = proc.stdout
            return output
    except FileNotFoundError:
        info("System nmap not found in PATH. Trying python-nmap if installed.")
    except subprocess.TimeoutExpired:
        error("Nmap scan timed out.")
        return output
    except Exception as e:
        info(f"System nmap attempt failed: {e}")

    # Fallback to python-nmap
    try:
        import nmap as _nmap
        scanner = _nmap.PortScanner()
        scan_str = ",".join(str(p) for p in ports)
        nmres = scanner.scan(target, scan_str)
        host = nmres.get("scan", {}).get(target, {})
        ports_info = host.get("tcp", {}) if isinstance(host.get("tcp"), dict) else {}
        for p in ports:
            pi = ports_info.get(p, {})
            state = pi.get("state") if isinstance(pi, dict) else None
            service = pi.get("name") if isinstance(pi, dict) else None
            output["ports"].append({"port": p, "open": state == "open", "service": service})
        banner("Nmap (python-nmap) scan completed.")
        output["raw"] = str(nmres)
        return output
    except Exception as e:
        info(f"python-nmap fallback failed or not installed: {e}")

    error("Nmap not available. Install nmap or python-nmap to use this feature.")
    return output

# ---------- CVE / NVD lookup (safe & read-only) ----------
def cve_lookup_nvd(term: str, api_key: Optional[str] = None) -> Dict[str, Any]:
    """
    Query NVD's public REST API for CVE metadata. This function is read-only and intended for defensive research.
    If an API key is provided (NVD_API_KEY), it should be passed to increase rate limits.
    """
    # Local import to avoid hard dependency when not used
    try:
        import requests
    except Exception:
        error("The 'requests' library is required for CVE lookups. Install via requirements.txt")
        return {"error": "missing_requests"}

    base = "https://services.nvd.nist.gov/rest/json/cves/1.0"
    params = {}
    if term.upper().startswith("CVE-"):
        params["cveId"] = term.upper()
    else:
        params["keyword"] = term
    headers = {"User-Agent": f"IZANAGI/{VERSION}"}
    if api_key:
        headers["apiKey"] = api_key

    try:
        r = requests.get(base, params=params, headers=headers, timeout=15)
        if r.status_code == 200:
            banner(f"NVD query successful (results: approx {len(r.json().get('result', {}).get('CVE_Items', []))})")
            return r.json()
        else:
            error(f"NVD query failed: HTTP {r.status_code}")
            return {"error": f"http_{r.status_code}", "text": r.text}
    except Exception as e:
        error(f"Failed to query NVD: {e}")
        return {"error": "exception", "reason": str(e)}

# ---------- Safe "cleanup" (MYRIAD TRUTHS) ----------
def myriad_truths_safe_cleanup():
    """
    SAFE cleanup:
    - Only deletes the toolkit's own temporary directory (TOOL_NAME tmp folder).
    - Requires interactive confirmation with the current system user.
    - Does NOT touch system recycle bin, event logs, or unrelated files.
    """
    print()
    info("MYRIAD TRUTHS: Safe cleanup selected.")
    info("This will remove only the toolkit's own temporary files directory:")
    print(f" -> {TMP_DIR}")
    print()
    confirm = input(Fore.MAGENTA + "Type 'DELETE-TMP' to confirm deletion of the toolkit's tmp files: " + Style.RESET_ALL)
    if confirm.strip() == "DELETE-TMP":
        try:
            if os.path.exists(TMP_DIR):
                shutil.rmtree(TMP_DIR)
                banner("Tool temporary files removed.")
            else:
                info("No temporary files directory found; nothing to remove.")
            # Recreate empty tmp dir for future runs
            os.makedirs(TMP_DIR, exist_ok=True)
        except Exception as e:
            error(f"Failed to remove temp dir: {e}")
    else:
        info("Cleanup cancelled by user. No system logs or recycle bin were touched.")

# ---------- Hidden/dev mode (non-malicious) ----------
def no_okami_dev_mode():
    """
    Developer / debug mode. This is NOT a black-hat function.
    It reveals basic environment, user, and allowed-scope reminders.
    """
    print()
    # Hidden debug snapshot with neutral white output (no prior mention in UI)
    print(Fore.WHITE + "System info snapshot:" + Style.RESET_ALL)
    try:
        print(Fore.WHITE + f"  User: {getpass.getuser()}" + Style.RESET_ALL)
    except Exception:
        print(Fore.WHITE + "  User: (unknown)" + Style.RESET_ALL)
    print(Fore.WHITE + f"  Python: {sys.version.splitlines()[0]}" + Style.RESET_ALL)
    print(Fore.WHITE + f"  Current directory: {os.getcwd()}" + Style.RESET_ALL)
    print(Fore.WHITE + f"  Toolkit tmp dir: {TMP_DIR}" + Style.RESET_ALL)
    print(Fore.WHITE + f"  Version: {VERSION}" + Style.RESET_ALL)
    print()

# ---------- CVE / vulnerability lookup placeholder ----------
def cve_lookup_placeholder(name_or_cve):
    """
    Placeholder for CVE lookup: This function intentionally DOES NOT fetch/exploit.
    It instructs the user where to check CVE databases for defensive research.
    """
    print()
    banner("CVE Lookup (placeholder)")
    print("This tool will NOT query remote exploit repositories or attempt exploitation.")
    print("Suggested next steps (manual & authorized):")
    print(" - Search NVD (nvd.nist.gov) or MITRE (cve.mitre.org) for the CVE identifier.")
    print(" - Use vendor advisories and official patches.")
    print(" - For automated CVE metadata lookups, integrate with official APIs and ensure rate limits and authentication.")
    print(f"Requested lookup term: {name_or_cve}")
    print("-> (placeholder) Please run an authorized query against NVD / MITRE / vendor advisory pages outside this script.")

# ---------- Menu & CLI ----------
def print_menu():
    print()
    print(Fore.CYAN + "IZANAGI - Penetration Testing Toolkit" + Style.RESET_ALL)
    print("1) SSH Connection / Banner Check")
    print("2) TCP Port Scan (connect)")
    print("3) Service Banner Grab")
    print("4) CVE Lookup (NVD read-only lookup)")
    print("5) MYRIAD TRUTHS (safe cleanup of toolkit files)")
    print("6) Nmap wrapper (system nmap or python-nmap fallback)")
    print("7) Save last scan report (JSON/CSV)")
    print("8) About / Legal / Usage")
    print("9) Exit")
    print()

def about_and_legal():
    print()
    banner("About IZANAGI")
    print("Version:", VERSION)
    print("Purpose: Penetration testing and defensive research assistance.")
    print()
    print("Legal / Ethical Notice:")
    print("- You must own or have explicit written authorization before testing any system.")
    print("- This toolkit does NOT contain exploits or evasion tools.")
    print("- Use logs and findings responsibly; coordinate with owners for remediation.")
    print()

def main_loop():
    print_ascii_art()
    about_and_legal()
    # We'll ask the user each loop whether to clear previous output before continuing.
    first_loop = True
    while True:
        try:
            # Before showing the menu on subsequent iterations, offer to clear the screen
            if not first_loop:
                confirm_and_clear()
            first_loop = False
            print_menu()
            choice = input(Fore.YELLOW + "Enter choice (or type a hidden command): " + Style.RESET_ALL).strip()
            # Hidden dev mode (non-malicious only)
            if choice == "NO_OKAMI":
                no_okami_dev_mode()
                continue

            if choice == "1":
                ip = input("Target IP/hostname: ").strip()
                port = input("Port [default 22]: ").strip()
                try:
                    p = int(port) if port else 22
                except:
                    error("Invalid port; using 22.")
                    p = 22
                ok, banner_txt = ssh_connection_check(ip, p)
                # store last results
                LAST_SCAN_RESULTS.clear()
                LAST_SCAN_RESULTS.update({"target": ip, "ports": [{"port": p, "open": ok, "banner": banner_txt}]})
            elif choice == "2":
                ip = input("Target IP/hostname: ").strip()
                ports_in = input("Ports (comma separated) e.g. 22,80,443 or range 1-1024: ").strip()
                # parse ports (support simple range)
                ports = []
                try:
                    if "-" in ports_in:
                        start, end = ports_in.split("-", 1)
                        ports = list(range(int(start), int(end)+1))
                    else:
                        ports = [int(x.strip()) for x in ports_in.split(",") if x.strip()]
                except Exception:
                    error("Invalid ports input. Using common ports [22,80,443].")
                    ports = [22,80,443]
                res = tcp_port_scan(ip, ports)
                # build structured results
                LAST_SCAN_RESULTS.clear()
                LAST_SCAN_RESULTS.update({"target": ip, "ports": []})
                for p, open_state in res.items():
                    LAST_SCAN_RESULTS["ports"].append({"port": p, "open": open_state, "banner": None})
            elif choice == "3":
                ip = input("Target IP/hostname: ").strip()
                port = input("Port to grab banner from (e.g. 22, 80): ").strip()
                try:
                    p = int(port)
                except:
                    error("Invalid port. Aborting banner grab.")
                    continue
                txt = grab_service_banner(ip, p)
                LAST_SCAN_RESULTS.clear()
                LAST_SCAN_RESULTS.update({"target": ip, "ports": [{"port": p, "open": bool(txt), "banner": txt}]})
            elif choice == "4":
                term = input("Enter CVE ID or product name (example: CVE-2021-44228 or OpenSSH): ").strip()
                api_key = input("(Optional) NVD API Key (or leave blank): ").strip() or None
                info("Querying NVD (read-only). Respect rate limits and authorization.)")
                res = cve_lookup_nvd(term, api_key)
                # Do not save NVD responses to LAST_SCAN_RESULTS automatically; print summary
                if isinstance(res, dict) and res.get("error"):
                    error(f"CVE lookup issue: {res.get('error')}")
                else:
                    items = res.get('result', {}).get('CVE_Items', []) if isinstance(res, dict) else []
                    banner(f"Found approx {len(items)} CVE item(s). See detailed output for the JSON structure.")
                    # Save a small cache file for user per-run
                    try:
                        fname = os.path.join(TMP_DIR, f"nvd_{term.replace(' ', '_')}.json")
                        with open(fname, 'w', encoding='utf-8') as fh:
                            json.dump(res, fh)
                        info(f"Saved NVD query JSON to {fname}")
                    except Exception as e:
                        info(f"Unable to cache NVD response: {e}")
            elif choice == "5":
                myriad_truths_safe_cleanup()
            elif choice == "6":
                # Nmap wrapper
                target = input("Target IP/hostname for nmap: ").strip()
                ports_in = input("Ports (comma separated) e.g. 22,80,443 or range 1-1024: ").strip()
                try:
                    if "-" in ports_in:
                        start, end = ports_in.split("-", 1)
                        ports = list(range(int(start), int(end)+1))
                    else:
                        ports = [int(x.strip()) for x in ports_in.split(",") if x.strip()]
                except Exception:
                    error("Invalid ports input. Using common ports [22,80,443].")
                    ports = [22,80,443]
                nmres = nmap_wrapper_scan(target, ports)
                # store last results
                LAST_SCAN_RESULTS.clear()
                LAST_SCAN_RESULTS.update(nmres)
            elif choice == "7":
                if not LAST_SCAN_RESULTS:
                    info("No scan results in memory. Run a scan first.")
                    continue
                mode = input("Save as (1) JSON or (2) CSV? [1/2]: ").strip()
                fname = input("Enter filename (will be created/overwritten): ").strip()
                if not fname:
                    error("No filename provided. Aborting save.")
                    continue
                if mode == "1":
                    save_report_json(LAST_SCAN_RESULTS, fname)
                else:
                    save_report_csv(LAST_SCAN_RESULTS, fname)
            elif choice == "8":
                about_and_legal()
            elif choice == "9":
                banner("Exiting IZANAGI.")
                break
            else:
                error("Invalid menu selection. Please choose a number from the menu.")
            # After handling an action, require confirmation whether to clear previous output before next action.
            # This keeps the console readable and gives users a chance to review results.
            # (confirm_and_clear will be called at the top of the next loop iteration)
        except KeyboardInterrupt:
            print()
            info("Interrupted by user. Returning to menu.")
        except Exception as e:
            error(f"Unexpected error in main loop: {e}")


def confirm_and_clear():
    """
    Ask the user whether to clear the previous output before continuing.
    If the user types a clear token (CLEAR or OK) the console will be cleared.
    Pressing Enter will leave the output as-is and continue.
    """
    try:
        resp = input(Fore.YELLOW + "Type 'CLEAR' to clear previous output, or press Enter to continue: " + Style.RESET_ALL).strip()
        if resp.upper() in ("CLEAR", "OK", "C"):
            try:
                os.system("cls" if os.name == "nt" else "clear")
            except Exception:
                # If clearing fails, just continue
                pass
    except Exception:
        pass

if __name__ == "__main__":
    main_loop()
